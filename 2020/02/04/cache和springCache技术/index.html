<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5"><title>学习笔记：cache 和spring cache 1 | 湖畔小屋</title><meta name="description" content="学习笔记：cache 和spring cache 1"><meta name="author" content="美式不加糖"><meta name="copyright" content="美式不加糖"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin><link rel="preconnect" href="//busuanzi.ibruce.info"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="学习笔记：cache 和spring cache 1"><meta name="twitter:description" content="学习笔记：cache 和spring cache 1"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png"><meta property="og:type" content="article"><meta property="og:title" content="学习笔记：cache 和spring cache 1"><meta property="og:url" content="http://yoursite.com/2020/02/04/cache%E5%92%8CspringCache%E6%8A%80%E6%9C%AF/"><meta property="og:site_name" content="湖畔小屋"><meta property="og:description" content="学习笔记：cache 和spring cache 1"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>const autoChangeMode = 'false'
var t = Cookies.get("theme");
if (autoChangeMode == '1'){
const isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
const isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
const isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

if (t === undefined){
  if (isLightMode) activateLightMode()
  else if (isDarkMode) activateDarkMode()
  else if (isNotSpecified || hasNoSupport){
    console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
    now = new Date();
    hour = now.getHours();
    isNight = hour < 6 || hour >= 18
    isNight ? activateDarkMode() : activateLightMode()
}
} else if (t == 'light') activateLightMode()
else activateDarkMode()


} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="http://yoursite.com/2020/02/04/cache%E5%92%8CspringCache%E6%8A%80%E6%9C%AF/"><link rel="prev" title="可重入锁" href="http://yoursite.com/2020/02/04/%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81/"><link rel="next" title="solr 7.0  tomcat 安装配置 + 中文分词" href="http://yoursite.com/2020/02/04/solr%20%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: 'Snackbar.bookmark.title',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  isHome: false,
  isPost: true
  
}</script><meta name="generator" content="Hexo 4.2.0"></head><body><header> <div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">湖畔小屋</a></span><span class="toggle-menu pull_right close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 清单</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li></ul></div></div></span></div></header><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">28</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">9</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">20</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 清单</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li></ul></div></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">目录</div><div class="sidebar-toc__content"></div></div></div><div id="body-wrap"><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"></div></div></div><main id="content-outer"><div id="top-container" style="background-image: url(https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png)"><div id="post-info"><div id="post-title"><div class="posttitle">学习笔记：cache 和spring cache 1</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 发表于 2020-02-04<span class="post-meta__separator">|</span><i class="fa fa-history fa-fw" aria-hidden="true"></i> 更新于 2020-02-04</time><span class="post-meta__separator">|</span><span><i class="fa fa-inbox post-meta__icon fa-fw" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/hexo/">hexo</a></span><div class="post-meta-wordcount"><div class="post-meta-pv-cv"><span><i class="fa fa-eye post-meta__icon fa-fw" aria-hidden="true"> </i>阅读量:</span><span id="busuanzi_value_page_pv"></span></div></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><html><head></head><body><p>缓存是实际工作中非常常用的一种提高性能的方法, 我们会在许多场景下来使用缓存。</p>
<p>本文通过一个简单的例子进行展开，通过对比我们原来的自定义缓存和 spring 的基于注释的 cache 配置方法，展现了 spring cache 的强大之处，然后介绍了其基本的原理，扩展点和使用场景的限制。通过阅读本文，你应该可以短时间内掌握 spring 带来的强大缓存技术，在很少的配置下即可给既有代码提供缓存能力。</p>
<p>概述</p>
<p>Spring 3.1 引入了激动人心的基于注释（annotation）的缓存（cache）技术，它本质上不是一个具体的缓存实现方案（例如EHCache 或者 OSCache），而是一个对缓存使用的抽象，通过在既有代码中添加少量它定义的各种 annotation，即能够达到缓存方法的返回对象的效果。</p>
<p>Spring 的缓存技术还具备相当的灵活性，不仅能够使用 SpEL（Spring Expression Language）来定义缓存的 key 和各种 condition，还提供开箱即用的缓存临时存储方案，也支持和主流的专业缓存例如 EHCache 集成。</p>
<p>其特点总结如下：</p>
<ul>
<li>通过少量的配置 annotation 注释即可使得既有代码支持缓存</li>
<li>支持开箱即用 Out-Of-The-Box，即不用安装和部署额外第三方组件即可使用缓存</li>
<li>支持 Spring Express Language，能使用对象的任何属性或者方法来定义缓存的 key 和 condition</li>
<li>支持 AspectJ，并通过其实现任何方法的缓存支持</li>
<li>支持自定义 key 和自定义缓存管理者，具有相当的灵活性和扩展性</li>
</ul>
<p>本文将针对上述特点对 Spring cache 进行详细的介绍，主要通过一个简单的例子和原理介绍展开，然后我们将一起看一个比较实际的缓存例子，最后会介绍 spring cache 的使用限制和注意事项。好吧，让我们开始吧</p>
<p>我们以前如何自己实现缓存的呢</p>
<p>这里先展示一个完全自定义的缓存实现，即不用任何第三方的组件来实现某种对象的内存缓存。</p>
<p>场景如下：</p>
<p>对一个账号查询方法做缓存，以账号名称为 key，账号对象为 value，当以相同的账号名称查询账号的时候，直接从缓存中返回结果，否则更新缓存。账号查询服务还支持 reload 缓存（即清空缓存）</p>
<p>首先定义一个实体类：账号类，具备基本的 id 和 name 属性，且具备 getter 和 setter 方法</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class Account {  </span><br><span class="line">    private int id;  </span><br><span class="line">    private String name;  </span><br><span class="line">    public Account(String name) {  </span><br><span class="line">        this.name = name;  </span><br><span class="line">    }  </span><br><span class="line">    public int getId() {  </span><br><span class="line">        return id;  </span><br><span class="line">    }  </span><br><span class="line">    public void setId(int id) {  </span><br><span class="line">        this.id = id;  </span><br><span class="line">    }  </span><br><span class="line">    public String getName() {  </span><br><span class="line">        return name;  </span><br><span class="line">    }  </span><br><span class="line">    public void setName(String name) {  </span><br><span class="line">        this.name = name;  </span><br><span class="line">    }  </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>



<p>然后定义一个缓存管理器，这个管理器负责实现缓存逻辑，支持对象的增加、修改和删除，支持值对象的泛型。如下：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import com.google.common.collect.Maps;  </span><br><span class="line">import java.util.Map;  </span><br><span class="line"></span><br><span class="line">public class CacheContext<t> {  </t></span><br><span class="line">    private Map<string, t> cache = Maps.newConcurrentMap();  </string,></span><br><span class="line">    public T get(String key){  </span><br><span class="line">        return  cache.get(key);  </span><br><span class="line">    }  </span><br><span class="line">    public void addOrUpdateCache(String key,T value) {  </span><br><span class="line">        cache.put(key, value);  </span><br><span class="line">    }  </span><br><span class="line">    // 根据 key 来删除缓存中的一条记录  </span><br><span class="line">    public void evictCache(String key) {  </span><br><span class="line">        if(cache.containsKey(key)) {  </span><br><span class="line">            cache.remove(key);  </span><br><span class="line">        }  </span><br><span class="line">    }  </span><br><span class="line">    // 清空缓存中的所有记录  </span><br><span class="line">    public void evictCache() {  </span><br><span class="line">        cache.clear();  </span><br><span class="line">    }  </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>



<p>好，现在我们有了实体类和一个缓存管理器，还需要一个提供账号查询的服务类，此服务类使用缓存管理器来支持账号查询缓存，如下：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">import com.google.common.base.Optional;  </span><br><span class="line">import org.slf4j.Logger;  </span><br><span class="line">import org.slf4j.LoggerFactory;  </span><br><span class="line">import org.springframework.stereotype.Service;  </span><br><span class="line">import javax.annotation.Resource;  </span><br><span class="line"></span><br><span class="line">@Service  </span><br><span class="line">public class AccountService1 {  </span><br><span class="line">    private final Logger logger = LoggerFactory.getLogger(AccountService1.class);  </span><br><span class="line">    @Resource  </span><br><span class="line">    private CacheContext<account> accountCacheContext;  </account></span><br><span class="line">    public Account getAccountByName(String accountName) {  </span><br><span class="line">        Account result = accountCacheContext.get(accountName);  </span><br><span class="line">        if (result != null) {  </span><br><span class="line">            logger.info("get from cache... {}", accountName);  </span><br><span class="line">            return result;  </span><br><span class="line">        }  </span><br><span class="line">        Optional<account> accountOptional = getFromDB(accountName);  </account></span><br><span class="line">        if (!accountOptional.isPresent()) {  </span><br><span class="line">            throw new IllegalStateException(String.format("can not find account by account name : [%s]", accountName));  </span><br><span class="line">        }  </span><br><span class="line">        Account account = accountOptional.get();  </span><br><span class="line">        accountCacheContext.addOrUpdateCache(accountName, account);  </span><br><span class="line">        return account;  </span><br><span class="line">    }  </span><br><span class="line">    public void reload() {  </span><br><span class="line">        accountCacheContext.evictCache();  </span><br><span class="line">    }  </span><br><span class="line">    private Optional<account> getFromDB(String accountName) {  </account></span><br><span class="line">        logger.info("real querying db... {}", accountName);  </span><br><span class="line">        //Todo query data from database  </span><br><span class="line">        return Optional.fromNullable(new Account(accountName));  </span><br><span class="line">    }  </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>



<p>现在我们开始写一个测试类，用于测试刚才的缓存是否有效</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">import org.junit.Before;  </span><br><span class="line">import org.junit.Test;  </span><br><span class="line">import org.slf4j.Logger;  </span><br><span class="line">import org.slf4j.LoggerFactory;  </span><br><span class="line">import org.springframework.context.support.ClassPathXmlApplicationContext;  </span><br><span class="line">import static org.junit.Assert.*;  </span><br><span class="line">public class AccountService1Test {  </span><br><span class="line">    private AccountService1 accountService1;  </span><br><span class="line">    private final Logger logger = LoggerFactory.getLogger(AccountService1Test.class);  </span><br><span class="line">    @Before  </span><br><span class="line">    public void setUp() throws Exception {  </span><br><span class="line">        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext("applicationContext1.xml");  </span><br><span class="line">        accountService1 = context.getBean("accountService1", AccountService1.class);  </span><br><span class="line">    }  </span><br><span class="line">    @Test  </span><br><span class="line">    public void testInject(){  </span><br><span class="line">        assertNotNull(accountService1);  </span><br><span class="line">    }  </span><br><span class="line">    @Test  </span><br><span class="line">    public void testGetAccountByName() throws Exception {  </span><br><span class="line">        accountService1.getAccountByName("accountName");  </span><br><span class="line">        accountService1.getAccountByName("accountName");  </span><br><span class="line">        accountService1.reload();  </span><br><span class="line">        logger.info("after reload ....");  </span><br><span class="line">        accountService1.getAccountByName("accountName");  </span><br><span class="line">        accountService1.getAccountByName("accountName");  </span><br><span class="line">    }  </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>



<p>按照分析，执行结果应该是：首先从数据库查询，然后直接返回缓存中的结果，重置缓存后，应该先从数据库查询，然后返回缓存中的结果. 查看程序运行的日志如下：</p>
<blockquote>
<p>00:53:17.166 [main] INFO  c.r.s.cache.example1.AccountService - real querying db… accountName</p>
<p>00:53:17.168 [main] INFO  c.r.s.cache.example1.AccountService - get from cache… accountName</p>
<p>00:53:17.168 [main] INFO  c.r.s.c.example1.AccountServiceTest - after reload ….</p>
<p>00:53:17.168 [main] INFO  c.r.s.cache.example1.AccountService - real querying db… accountName</p>
<p>00:53:17.169 [main] INFO  c.r.s.cache.example1.AccountService - get from cache… accountName</p>
</blockquote>
<p>可以看出我们的缓存起效了，但是这种自定义的缓存方案有如下劣势：</p>
<ul>
<li>缓存代码和业务代码耦合度太高，如上面的例子，AccountService 中的 getAccountByName（）方法中有了太多缓存的逻辑，不便于维护和变更</li>
<li>不灵活，这种缓存方案不支持按照某种条件的缓存，比如只有某种类型的账号才需要缓存，这种需求会导致代码的变更</li>
<li>缓存的存储这块写的比较死，不能灵活的切换为使用第三方的缓存模块</li>
</ul>
<p>如果你的代码中有上述代码的影子，那么你可以考虑按照下面的介绍来优化一下你的代码结构了，也可以说是简化，你会发现，你的代码会变得优雅的多！</p>
<p>Spring cache是如何做的呢</p>
<p>我们对AccountService1 进行修改，创建AccountService2:</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">import com.google.common.base.Optional;  </span><br><span class="line">import com.rollenholt.spring.cache.example1.Account;  </span><br><span class="line">import org.slf4j.Logger;  </span><br><span class="line">import org.slf4j.LoggerFactory;  </span><br><span class="line">import org.springframework.cache.annotation.Cacheable;  </span><br><span class="line">import org.springframework.stereotype.Service;  </span><br><span class="line"></span><br><span class="line">@Service  </span><br><span class="line">public class AccountService2 {  </span><br><span class="line">    private final Logger logger = LoggerFactory.getLogger(AccountService2.class);  </span><br><span class="line">    // 使用了一个缓存名叫 accountCache  </span><br><span class="line">    @Cacheable(value="accountCache")  </span><br><span class="line">    public Account getAccountByName(String accountName) {  </span><br><span class="line">        // 方法内部实现不考虑缓存逻辑，直接实现业务  </span><br><span class="line">        logger.info("real querying account... {}", accountName);  </span><br><span class="line">        Optional<account> accountOptional = getFromDB(accountName);  </account></span><br><span class="line">        if (!accountOptional.isPresent()) {  </span><br><span class="line">            throw new IllegalStateException(String.format("can not find account by account name : [%s]", accountName));  </span><br><span class="line">        }  </span><br><span class="line">        return accountOptional.get();  </span><br><span class="line">    }  </span><br><span class="line">    private Optional<account> getFromDB(String accountName) {  </account></span><br><span class="line">        logger.info("real querying db... {}", accountName);  </span><br><span class="line">        //Todo query data from database  </span><br><span class="line">        return Optional.fromNullable(new Account(accountName));  </span><br><span class="line">    }  </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>



<p>我们注意到在上面的代码中有一行：</p>
<blockquote>
<p>@Cacheable(value=”accountCache”)</p>
</blockquote>
<p>这个注释的意思是，当调用这个方法的时候，会从一个名叫 accountCache 的缓存中查询，如果没有，则执行实际的方法（即查询数据库），并将执行的结果存入缓存中，否则返回缓存中的对象。这里的缓存中的 key 就是参数 accountName，value 就是 Account 对象。“accountCache”缓存是在 spring*.xml 中定义的名称。我们还需要一个 spring 的配置文件来支持基于注释的缓存</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><beans xmlns="http://www.springframework.org/schema/beans" < span><br><span class="line">       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"  </span><br><span class="line">       xmlns:context="http://www.springframework.org/schema/context"  </span><br><span class="line">       xmlns:cache="http://www.springframework.org/schema/cache"  </span><br><span class="line">       xsi:schemaLocation="http://www.springframework.org/schema/beans  </span><br><span class="line">http://www.springframework.org/schema/beans/spring-beans.xsd  </span><br><span class="line">http://www.springframework.org/schema/context  </span><br><span class="line">http://www.springframework.org/schema/context/spring-context.xsd  </span><br><span class="line">http://www.springframework.org/schema/cache  </span><br><span class="line">http://www.springframework.org/schema/cache/spring-cache.xsd">  </span><br><span class="line">    <context:component-scan base-package="com.rollenholt.spring.cache">  </context:component-scan></span><br><span class="line">    <context:annotation-config>  </context:annotation-config></span><br><span class="line">    <cache:annotation-driven>  </cache:annotation-driven></span><br><span class="line">    <bean id="cacheManager" class="org.springframework.cache.support.SimpleCacheManager">  </bean></span><br><span class="line">        <property name="caches">  </property></span><br><span class="line">            <set>  </set></span><br><span class="line">                <bean class="org.springframework.cache.concurrent.ConcurrentMapCacheFactoryBean">  </bean></span><br><span class="line">                    <property name="name" value="default">  </property></span><br><span class="line">                  </span><br><span class="line">                <bean class="org.springframework.cache.concurrent.ConcurrentMapCacheFactoryBean">  </bean></span><br><span class="line">                    <property name="name" value="accountCache">  </property></span><br><span class="line">                  </span><br><span class="line">              </span><br><span class="line">          </span><br><span class="line">       </span><br><span class="line"></span></beans></span><br></pre></td></tr></tbody></table></figure></div>



<p>注意这个 spring 配置文件有一个关键的支持缓存的配置项：</p>
<blockquote>
<p><cache:annotation-driven></cache:annotation-driven></p>
</blockquote>
<p>这个配置项缺省使用了一个名字叫 cacheManager 的缓存管理器，这个缓存管理器有一个 spring 的缺省实现，即 org.springframework.cache.support.SimpleCacheManager，这个缓存管理器实现了我们刚刚自定义的缓存管理器的逻辑，它需要配置一个属性 caches，即此缓存管理器管理的缓存集合，除了缺省的名字叫 default 的缓存，我们还自定义了一个名字叫 accountCache 的缓存，使用了缺省的内存存储方案 ConcurrentMapCacheFactoryBean，它是基于 java.util.concurrent.ConcurrentHashMap 的一个内存缓存实现方案。</p>
<p>然后我们编写测试程序：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">import org.junit.Before;  </span><br><span class="line">import org.junit.Test;  </span><br><span class="line">import org.slf4j.Logger;  </span><br><span class="line">import org.slf4j.LoggerFactory;  </span><br><span class="line">import org.springframework.context.support.ClassPathXmlApplicationContext;  </span><br><span class="line">import static org.junit.Assert.*;  </span><br><span class="line">public class AccountService2Test {  </span><br><span class="line">    private AccountService2 accountService2;  </span><br><span class="line">    private final Logger logger = LoggerFactory.getLogger(AccountService2Test.class);  </span><br><span class="line">    @Before  </span><br><span class="line">    public void setUp() throws Exception {  </span><br><span class="line">        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext("applicationContext2.xml");  </span><br><span class="line">        accountService2 = context.getBean("accountService2", AccountService2.class);  </span><br><span class="line">    }  </span><br><span class="line">    @Test  </span><br><span class="line">    public void testInject(){  </span><br><span class="line">        assertNotNull(accountService2);  </span><br><span class="line">    }  </span><br><span class="line">    @Test  </span><br><span class="line">    public void testGetAccountByName() throws Exception {  </span><br><span class="line">        logger.info("first query...");  </span><br><span class="line">        accountService2.getAccountByName("accountName");  </span><br><span class="line">        logger.info("second query...");  </span><br><span class="line">        accountService2.getAccountByName("accountName");  </span><br><span class="line">    }  </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>



<p>上面的测试代码主要进行了两次查询，第一次应该会查询数据库，第二次应该返回缓存，不再查数据库，我们执行一下，看看结果</p>
<blockquote>
<p>01:10:32.435 [main] INFO  c.r.s.c.example2.AccountService2Test - first query…</p>
<p>01:10:32.456 [main] INFO  c.r.s.cache.example2.AccountService2 - real querying account… accountName</p>
<p>01:10:32.457 [main] INFO  c.r.s.cache.example2.AccountService2 - real querying db… accountName</p>
<p>01:10:32.458 [main] INFO  c.r.s.c.example2.AccountService2Test - second query…</p>
</blockquote>
<p>可以看出我们设置的基于注释的缓存起作用了，而在 AccountService.java 的代码中，我们没有看到任何的缓存逻辑代码，只有一行注释：@Cacheable(value=”accountCache”)，就实现了基本的缓存方案，是不是很强大？</p>
</body></html></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">美式不加糖</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://yoursite.com/2020/02/04/cache%E5%92%8CspringCache%E6%8A%80%E6%9C%AF/">http://yoursite.com/2020/02/04/cache%E5%92%8CspringCache%E6%8A%80%E6%9C%AF/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://yoursite.com">湖畔小屋</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/wechat.jpg" alt="微信"><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/alipay.jpg" alt="支付寶"><div class="post-qr-code__desc">支付寶</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2020/02/04/%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81/"><img class="prev_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">上一篇</div><div class="prev_info"><span>可重入锁</span></div></a></div><div class="next-post pull_right"><a href="/2020/02/04/solr%20%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"><img class="next_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">下一篇</div><div class="next_info"><span>solr 7.0  tomcat 安装配置 + 中文分词</span></div></a></div></nav></div></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2020 By 美式不加糖</div><div class="framework-info"><span>驱动 </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script></body></html>